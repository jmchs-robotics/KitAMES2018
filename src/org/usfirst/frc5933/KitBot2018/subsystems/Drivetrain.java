// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5933.KitBot2018.subsystems;

import org.usfirst.frc5933.KitBot2018.Robot;
import org.usfirst.frc5933.KitBot2018.RobotMap;
import org.usfirst.frc5933.KitBot2018.commands.*;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.wpilibj.command.Subsystem;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StickyFaults;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Drivetrain extends Subsystem {
	//Drivetrain constants
	
	//Field-tested value. Seems to work well.... or we built an awesome drivetrain this year.
	//But it's probably the software.
	public static final double kPGyroConstant = 0.01;
	public static final double kPGyroTurnConstant = 0.01;
	
	/**<p>
	 * Encoder runs 4096 steps/revolution
	 * Wheel is 4" diameter; encoder is attached directly to output shaft
	 * therefore, wheel moves 4π"/revolution.
	 * 4π"/4096 steps ≈ π"/1024 steps ≈ 0.0030679616"/step. </p>
	 * Also, 4096 steps/4π" ≈ 325.9493209 steps/inch.
	 * </p>
	 * One can take a value in inches and multiply by kEncoderTicksPerInch
	 * to get the number of encoder ticks needed to reach that distance in inches.
	 */
	public static final double kEncoderTicksPerInch = 325.9493209;
	
	//PID constants
	private static final double kLeftP = 0;
	private static final double kLeftI = 0;
	private static final double kLeftD = 0;
	private static final double kLeftF = 0;
	
	private static final double kRightP = 0;
	private static final double kRightI = 0;
	private static final double kRightD = 0;
	private static final double kRightF = 0;
	
	private static final double minVBusOutVal = 0.2;
	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final WPI_TalonSRX leftMaster = RobotMap.drivetrainLeftMaster;
	private final WPI_TalonSRX rightMaster = RobotMap.drivetrainRightMaster;

	private final DifferentialDrive robotDrive = RobotMap.drivetrainRobotDrive;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private final WPI_TalonSRX leftFollower1 = RobotMap.drivetrainLeftFollower1;
	private final WPI_TalonSRX leftFollower2 = RobotMap.drivetrainLeftFollower2;
	private final WPI_TalonSRX rightFollower1 = RobotMap.drivetrainRightFollower1;
	private final WPI_TalonSRX rightFollower2 = RobotMap.drivetrainRightFollower2;
	private final ADXRS450_Gyro gyro = RobotMap.roborioGyro;

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new DefaultDrivetrain());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void init() {
		setNominalAndMax();
		initGyro();
		setFollower();
		configMasterFeedback(0, 0);
		
		setVoltageFullOut(12, 0);
		
		leftMaster.set(ControlMode.PercentOutput, 0);
		rightMaster.set(ControlMode.PercentOutput, 0);
	}

	public void teleopInit() {
		setCurrentLimit(0,0,0,10);
		setBrakeMode(false);
		enableCurrentLimit(true);
	
		leftMaster.set(ControlMode.PercentOutput, 0);
		rightMaster.set(ControlMode.PercentOutput, 0);
	
	}

	public void autonomousInit() {
		setCurrentLimit(0,0,0,10);
		setBrakeMode(true);
		enableCurrentLimit(true);
	
		leftMaster.set(ControlMode.PercentOutput, 0);
		rightMaster.set(ControlMode.PercentOutput, 0);
	}

	@Override
	public void periodic() {
		// Put code here to be run every loop

		SmartDashboard.putNumber("Joystick X: ", Robot.oi.getDriverStick().getX());
		SmartDashboard.putNumber("Joystick Y: ", Robot.oi.getDriverStick().getY());
		SmartDashboard.putNumber("Joystick Magnitude: ", Robot.oi.getDriverStick().getMagnitude());
		
		SmartDashboard.putNumber("Left Out: ", leftMaster.getMotorOutputPercent());
		SmartDashboard.putNumber("Right Out: ", rightMaster.getMotorOutputPercent());
		
		SmartDashboard.putNumber("Left Enc: ", getLeftEncoderPos(0));
		SmartDashboard.putNumber("Right Enc: ", getRightEncoderPos(0));
		SmartDashboard.putNumber("Gyro Out: ", getGyroHeading());
	}

	private void setNominalAndMax() {
		configPeakOutput(leftMaster, 1.0f, -1.0f);
		configNominalOutput(leftMaster, +0.0f, -0.0f);
		configPeakOutput(leftFollower1, 1.0f, -1.0f);
		configNominalOutput(leftFollower1, +0.0f, -0.0f);
		configPeakOutput(leftFollower2, 1.0f, -1.0f);
		configNominalOutput(leftFollower2, +0.0f, -0.0f);
		
		configPeakOutput(rightMaster, 1.0f, -1.0f);
		configNominalOutput(rightMaster, +0.0f, -0.0f);
		configPeakOutput(rightFollower1, 1.0f, -1.0f);
		configNominalOutput(rightFollower1, +0.0f, -0.0f);
		configPeakOutput(rightFollower2, 1.0f, -1.0f);
		configNominalOutput(rightFollower2, +0.0f, -0.0f);
	}
	
	private void setVoltageFullOut(double voltage, int timeout) {
		leftMaster.configVoltageCompSaturation(voltage, timeout);
		rightMaster.configVoltageCompSaturation(voltage, timeout);
		leftFollower1.configVoltageCompSaturation(voltage, timeout);
		rightFollower1.configVoltageCompSaturation(voltage, timeout);
		leftFollower2.configVoltageCompSaturation(voltage, timeout);
		rightFollower2.configVoltageCompSaturation(voltage, timeout);
	}

	private void configPeakOutput(WPI_TalonSRX controller, double percentForward, double percentReverse) {
		controller.configPeakOutputForward(percentForward, 0);
		controller.configPeakOutputReverse(percentReverse, 0);
	}

	private void configNominalOutput(WPI_TalonSRX controller, double percentForward, double percentReverse) {
		controller.configNominalOutputForward(percentForward, 0);
		controller.configNominalOutputReverse(percentReverse, 0);
	}

	private void setBrakeMode(boolean brake) {
		if(brake) {
			leftMaster.setNeutralMode(NeutralMode.Brake);
			rightMaster.setNeutralMode(NeutralMode.Brake);
			leftFollower1.setNeutralMode(NeutralMode.Brake);
			rightFollower1.setNeutralMode(NeutralMode.Brake);
			leftFollower2.setNeutralMode(NeutralMode.Brake);
			rightFollower2.setNeutralMode(NeutralMode.Brake);
		}else {
			leftMaster.setNeutralMode(NeutralMode.Coast);
			rightMaster.setNeutralMode(NeutralMode.Coast);
			leftFollower1.setNeutralMode(NeutralMode.Coast);
			rightFollower1.setNeutralMode(NeutralMode.Coast);
			leftFollower2.setNeutralMode(NeutralMode.Coast);
			rightFollower2.setNeutralMode(NeutralMode.Coast);
		}
	}
	
	public void configMasterFeedback(int pidIndx, int timeoutMs) {
		leftMaster.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, pidIndx, timeoutMs);
		configMasterPID(leftMaster, 0, kLeftP, kLeftI, kLeftD, kLeftF, timeoutMs);
		
		rightMaster.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, pidIndx, timeoutMs);
		configMasterPID(rightMaster, 0, kRightP, kRightI, kRightD, kRightF, timeoutMs);
	}
	
	public void configMasterPID(WPI_TalonSRX masterController, int pidIdx, double p, double i, double d, double f, int timeoutMs) {
		masterController.config_kP(pidIdx, p, timeoutMs);
		masterController.config_kI(pidIdx, i, timeoutMs);
		masterController.config_kD(pidIdx, d, timeoutMs);
		masterController.config_kF(pidIdx, f, timeoutMs);
	}

	/**
	 * For simpler control, set all values to 0 except the continuousLimit parameter. The timeout is
	 * irrelevant right now because the method is void: it just swallows any returned errors.
	 * @param
	 * msErrorTimeout
	 * The timeout (in ms) to pause each config to wait for confirmation/errors
	 * @param
	 * peakCurrent
	 * The maximum allowable current per motor controller for the peakDuration
	 * @param
	 * peakDuration
	 * The time (in ms) to allow the motor controllers to pull the peakCurrent
	 * @param
	 * continuousLimit
	 * The current limit for every time other than the peak.
	 */
	private void setCurrentLimit(int msErrorTimeout, int peakCurrent, int peakDuration, int continuousLimit) {
		leftMaster.configPeakCurrentLimit(peakCurrent, msErrorTimeout);
		leftMaster.configPeakCurrentDuration(peakDuration, msErrorTimeout);
		//again, it's amps then timeout for error reporting. We don't want to wait so much.
		leftMaster.configContinuousCurrentLimit(continuousLimit, msErrorTimeout);
		
		leftFollower1.configPeakCurrentLimit(peakCurrent, msErrorTimeout);
		leftFollower1.configPeakCurrentDuration(peakDuration, msErrorTimeout);
		//again, it's amps then timeout for error reporting. We don't want to wait so much.
		leftFollower1.configContinuousCurrentLimit(continuousLimit, msErrorTimeout);
		
		leftFollower2.configPeakCurrentLimit(peakCurrent, msErrorTimeout);
		leftFollower2.configPeakCurrentDuration(peakDuration, msErrorTimeout);
		//again, it's amps then timeout for error reporting. We don't want to wait so much.
		leftFollower2.configContinuousCurrentLimit(continuousLimit, msErrorTimeout);

		rightMaster.configPeakCurrentLimit(peakCurrent, msErrorTimeout);
		rightMaster.configPeakCurrentDuration(peakDuration, msErrorTimeout);
		//again, it's amps then timeout for error reporting. We don't want to wait so much.
		rightMaster.configContinuousCurrentLimit(continuousLimit, msErrorTimeout);
		
		rightFollower1.configPeakCurrentLimit(peakCurrent, msErrorTimeout);
		rightFollower1.configPeakCurrentDuration(peakDuration, msErrorTimeout);
		//again, it's amps then timeout for error reporting. We don't want to wait so much.
		rightFollower1.configContinuousCurrentLimit(continuousLimit, msErrorTimeout);
		
		rightFollower2.configPeakCurrentLimit(peakCurrent, msErrorTimeout);
		rightFollower2.configPeakCurrentDuration(peakDuration, msErrorTimeout);
		//again, it's amps then timeout for error reporting. We don't want to wait so much.
		rightFollower2.configContinuousCurrentLimit(continuousLimit, msErrorTimeout);
	}
	
	private void enableCurrentLimit(boolean enable) {
		leftMaster.enableCurrentLimit(enable);
		rightMaster.enableCurrentLimit(enable);
		rightFollower1.enableCurrentLimit(enable);
		leftFollower1.enableCurrentLimit(enable);
		rightFollower2.enableCurrentLimit(enable);
		leftFollower2.enableCurrentLimit(enable);
	}

	private void setFollower() {
		leftFollower1.set(ControlMode.Follower, 10);
		leftFollower2.set(ControlMode.Follower, 10);

		rightFollower1.set(ControlMode.Follower, 11);
		rightFollower2.set(ControlMode.Follower, 11);
	}
	
	public double getLeftEncoderPos(int pidIdx) {
		return leftMaster.getSelectedSensorPosition(pidIdx);
	}
	
	public double getRightEncoderPos(int pidIdx) {
		return rightMaster.getSelectedSensorPosition(pidIdx);
	}

	public void arcadeDrive() {
		robotDrive.arcadeDrive(-Robot.oi.getDriverStick().getY(), Robot.oi.getDriverStick().getX());
	}
	
	public void tankDrive(double leftVal, double rightVal) {
		leftMaster.set(ControlMode.PercentOutput, leftVal);
		rightMaster.set(ControlMode.PercentOutput, rightVal);
	}
	
	
	//goodies for gyro
	private void initGyro() {
		gyro.calibrate();
	}
	
	public void resetGyro() {
		gyro.reset();
	}
	
	public double getGyroHeading() {
		return gyro.getAngle();
	}

	public double thresholdVBus(double val) {
		if(Math.abs(val) < minVBusOutVal) {
			val = Math.signum(val) * minVBusOutVal;
		}
		return val;
	}

	public void resetEncoders() {
		leftMaster.setSelectedSensorPosition(0, 0, 20);
		rightMaster.setSelectedSensorPosition(0, 0, 20);
	}
}

